<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.8.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/site.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/site.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="never giveup stronger survival">
<meta property="og:type" content="website">
<meta property="og:title" content="dang&#39;s technology blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="dang&#39;s technology blog">
<meta property="og:description" content="never giveup stronger survival">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="dang&#39;s technology blog">
<meta name="twitter:description" content="never giveup stronger survival">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>dang's technology blog - Coding Fighting</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dang's technology blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Coding Fighting</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/31167/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/31167/" class="post-title-link" itemprop="url">浏览器渲染过程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-07-02 15:12:16 / 修改时间：16:13:45" itemprop="dateCreated datePublished" datetime="2020-07-02T15:12:16+08:00">2020-07-02</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/浏览器/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>浏览器拿到服务器的资源是如何处理的？</p>
<p>&lt;!-- more --&gt;</p>
<p>资源主要包括HTML,CSS,JS等，先看下图：
<img src="https://imgkr.cn-bj.ufileos.com/3db9a442-df04-4e79-902a-31ac102fe5ba.png" alt="pic"></p>
<p>主要步骤：</p>
<ol>
<li>根据HTML构建DOM</li>
<li>根据CSS构建CSSOM</li>
<li>合并DOM和CSSOM生成Render Tree</li>
<li>Layout: 根据渲染对象计算出每个对象的尺寸和位置等</li>
<li>painting： 将上一步的结果渲染到页面上</li>
</ol>
<p>window.onload和DOMcontentLoaded有什么区别？</p>
<ul>
<li>HTML parser构建完DOM树后document会派发DOMcontentLoaded事件</li>
<li>所有资源(img等)全部加载完毕才会触发onload事件</li>
</ul>
<p>script标签中defer和async分别什么意思？
<img src="https://imgkr.cn-bj.ufileos.com/f5440a32-f552-4aaa-a83e-f0621369c413.png" alt="pic">
说明：如果没有defer和async那么script的下载和执行都会阻塞
有defer下载时不阻塞，会在DOM构建完，DOMcontentLoaded之前执行
有async下载时不阻塞，下载完立即执行，执行时阻塞</p>
<p>CSS会阻塞HTML的解析和渲染吗？
CSS不会阻塞HTML的解析但是会阻塞HTML的渲染，所以感观上CSS会阻塞页面的，且css加载会阻塞后面的js语句的执行</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/40340/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/40340/" class="post-title-link" itemprop="url">Event Loop</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-28 16:54:53" itemprop="dateCreated datePublished" datetime="2020-06-28T16:54:53+08:00">2020-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-01 22:27:40" itemprop="dateModified" datetime="2020-07-01T22:27:40+08:00">2020-07-01</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/浏览器/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>执行栈与任务队列</strong>：
由于JS是单线程的，将同步代码与异步代码进行了区分：
遇到同步代码总是放入执行栈中，异步代码放入任务队列中，总是清空任务队列(总是先执行同步代码),再查询任务队列中有没有异步代码，有则执行。</p>
<p>&lt;!-- more --&gt;</p>
<h1>浏览器环境</h1>
<p><strong>执行流程：</strong>
将script整个看成一个task，
执行机制：
1.执行<strong>一个</strong>task(第一次执行同步代码)
2.执行<strong>所有</strong>microtask
3.重复1，2直到清空</p>
<p>代码示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function sleep(time) &#123;</span><br><span class="line">  let startTime = new Date()</span><br><span class="line">  while (new Date() - startTime &lt; time) &#123;&#125;</span><br><span class="line">  console.log(&apos;1s over&apos;)</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setTimeout - 1&apos;)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;setTimeout - 1 - 1&apos;)</span><br><span class="line">      sleep(1000)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(resolve =&gt; resolve()).then(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;setTimeout - 1 - then&apos;)</span><br><span class="line">      new Promise(resolve =&gt; resolve()).then(() =&gt; &#123;</span><br><span class="line">          console.log(&apos;setTimeout - 1 - then - then&apos;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  sleep(1000)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;setTimeout - 2&apos;)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;setTimeout - 2 - 1&apos;)</span><br><span class="line">      sleep(1000)</span><br><span class="line">  &#125;)</span><br><span class="line">  new Promise(resolve =&gt; resolve()).then(() =&gt; &#123;</span><br><span class="line">      console.log(&apos;setTimeout - 2 - then&apos;)</span><br><span class="line">      new Promise(resolve =&gt; resolve()).then(() =&gt; &#123;</span><br><span class="line">          console.log(&apos;setTimeout - 2 - then - then&apos;)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">  sleep(1000)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>执行结果（浏览器）：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout - 1 //1为单个task</span><br><span class="line">1s over</span><br><span class="line">setTimeout - 1 - then</span><br><span class="line">setTimeout - 1 - then - then </span><br><span class="line">setTimeout - 2 //2为单个task</span><br><span class="line">1s over</span><br><span class="line">setTimeout - 2 - then</span><br><span class="line">setTimeout - 2 - then - then</span><br><span class="line">setTimeout - 1 - 1</span><br><span class="line">1s over</span><br><span class="line">setTimeout - 2 - 1</span><br><span class="line">1s over</span><br></pre></td></tr></table></figure></p>
<h1>node环境</h1>
<p>六个阶段：</p>
<ol>
<li>timer (setTimeout 和 setInterval的回调)</li>
<li>I/O 回调</li>
<li>idle</li>
<li>poll</li>
<li>check (setImmediate回调)</li>
<li>close回调 (如socket.on('close',callback)的执行)
&lt;font color=&quot;red&quot;&gt;每一个阶段是一个queue(队列),清空了当前阶段的queue才会进入下一个阶段&lt;font&gt;</li>
</ol>
<p><strong>process.nextTick()会加入当前执行栈末尾，任务队列之前(也就是在所有异步任务之前执行)</strong>
<strong>setImmediate方法则是在当前&quot;任务队列&quot;的尾部添加事件</strong></p>
<p><strong>执行流程:</strong>
循环之前：同步任务，nextTick()
开始循环：当前阶段queue, nextTick() queue , Micortask queue, 下个阶段</p>
<p>代码示例：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">new Promise((resolve) =&gt; &#123;</span><br><span class="line">    console.log(1);			</span><br><span class="line">    </span><br><span class="line">    process.nextTick(() =&gt; &#123;</span><br><span class="line">    	console.log(2);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    resolve();</span><br><span class="line">    </span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">    	console.log(6);</span><br><span class="line">	&#125;, 0);</span><br><span class="line">    </span><br><span class="line">    process.nextTick(() =&gt; &#123;</span><br><span class="line">    	console.log(3);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    console.log(4);				</span><br><span class="line">&#125;).then(() =&gt; &#123;</span><br><span class="line">	process.nextTick(() =&gt; &#123;</span><br><span class="line">    	console.log(&apos;nextTick&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(5);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(7);</span><br></pre></td></tr></table></figure></p>
<p>执行结果(node)：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">nextTick</span><br><span class="line">6</span><br></pre></td></tr></table></figure></p>
<p>墙裂建议参考：
<a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener">歪果大佬，提升英语水平</a>
<a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882" target="_blank" rel="noopener">参考二</a>
<a href="https://github.com/SunShinewyf/issue-blog/issues/34#issuecomment-371106502" target="_blank" rel="noopener">github</a>
建议参考：
<a href="https://segmentfault.com/a/1190000013660033?utm_source=channel-hottest" target="_blank" rel="noopener">思否</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/34038/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/34038/" class="post-title-link" itemprop="url">世界上最复杂的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-28 01:35:37" itemprop="dateCreated datePublished" datetime="2020-06-28T01:35:37+08:00">2020-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-02 16:13:47" itemprop="dateModified" datetime="2020-07-02T16:13:47+08:00">2020-07-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>从浏览器地址栏输入URL后回车，背后会进行哪些技术步骤？
这个问题我愿称之为世界上最复杂的问题，甚至可以从回车键的电流回路闭合或者触摸屏电容变化讲起，，，
<a href="https://www.zhihu.com/question/34873227" target="_blank" rel="noopener">知乎</a>
<a href="https://www.zhihu.com/question/34873227" target="_blank" rel="noopener">百度大佬</a></p>
<p>&lt;!-- more --&gt;</p>
<h1>从浏览器地址栏输入URL后回车，背后会进行哪些技术步骤</h1>
<h2>简单流程</h2>
<ol>
<li>浏览器分析URL</li>
<li>浏览器向DNS请求解析域名的IP</li>
<li>浏览器与服务器建立TCP链接(三次握手)</li>
<li>浏览器发出GET请求</li>
<li>服务器响应index.html页面</li>
<li>TCP链接释放</li>
<li>浏览器解析页面</li>
</ol>
<h2>说明</h2>
<ol>
<li>地址栏会先分析字符串是否符合URL的规则，符合则进行下一步</li>
<li>从域名到IP：</li>
</ol>
<ul>
<li>查缓存：浏览器缓存 -&gt; 系统缓存 -&gt; 路由缓存 -&gt; 系统hosts文件 ， 上述都没有则查询DNS服务器</li>
<li>查询DNS服务器：通过TCP/IP(中的UDP)联系<strong>本地</strong>DNS服务器8.8.8.8(自己的是1.1.1.1),一般由网络接入服务商提供(如中国移动)，DNS服务器也会查询自己的缓存 -&gt; 联系根域名服务器 -&gt;  根域名服务器给出一个域服务器地址让本地服务器去查 -&gt; 域服务器告诉本地服务器解析服务器地址继续让本地服务器去查 -&gt; 本地服务器缓存
<em>一个参数TTL(time to live)是本地DNS服务器缓存的时间，最长24h</em></li>
</ul>
<h2>TLS/SSL过程</h2>
<ol>
<li>client Hello: 客户端向服务端发送随机数Random1, SSL Version, 加密套件</li>
<li>server Hello: 服务端向客户端发送随机数Random2, 加密套件(从上一个加密套件得到的算法等)</li>
<li>certificate: 服务端将自己的证书下发给客户端</li>
<li>certificate verify:  客户端先从CA验证证书的合法性，再取出公钥，利用公钥加密Random3，生成premaster key</li>
<li>client key exchange： 服务端拿到premaster key后用私钥解密出Random3</li>
<li>client 和 client 使用 Random1 + Random2 + Random3 作为密钥进行加密通话</li>
</ol>
<h2>三次握手/四次挥手</h2>
<p>各字段意义：
SYN: 建立连接标志位
ACK: ack是否有效标志位
ack: 之前的信息成功接受
seq: 序号(分片后合并的依据)
FIN: 断开连接标志位</p>
<h3>三次握手</h3>
<p><img src="https://imgkr.cn-bj.ufileos.com/773e6bd2-b05d-4206-871f-ca431a11f6ce.png" alt="pic"></p>
<h3>四次挥手</h3>
<p><img src="https://imgkr.cn-bj.ufileos.com/981b6e65-0fc6-4218-a6cd-a416b7231b5b.png" alt="pic"></p>
<ul>
<li>
<p>为什么握手是三次，两次行吗？
首先明白三次握手的目的：第一次服务端知道了客户端有发送的能力，服务端有接受的能力；第二次客户端知道了服务端有接受和发送的能力，自己也有接受和发送到能力，但此时服务端还不知道客户端有没有接受的能力和服务端有没有发送的能力。<em>比如客户端握手一次没有响应再握手一次得到响应此时建立连接，传输数据断开连接完事第一次握手到达了服务端，此时服务端响应并一种等待数据造成了浪费</em></p>
</li>
<li>
<p>为什么握手是三次而挥手是四次？
四次挥手也可以理解成三次，将二三次合并就和三次握手一样了，之所以不能合并是因为第三次发送FIN是依据上一层(应用层)指令(有响应还没发完)，不能一起发送回复信息和FIN,所以一定有间隔。</p>
</li>
<li>
<p>三次握手可以携带数据吗？
<strong>第一次，第二次不可以</strong>,第三次可以：为了防止攻击服务器(第一次时携带大量数据让服务器解析)</p>
</li>
</ul>
<h2>TCP/UDP异同</h2>
<ol>
<li>UDP尽最大努力交付，不保证可靠， TCP可靠</li>
<li>TCP可靠，</li>
<li>TCP面向字节流，UDP面向报文
<em>如何理解面向报文与面向字节流，面向连接与无连接？</em>
面向报文：UDP面对应用层下发的信息（报文）,不做任何处理，直接发送报文。因此应用程序需选择合适的报文下发。
面向字节流：TCP有一个缓冲，将应用下发的数据块或进行拆分或进行合并再进行发送
面向连接；类似通电话，双方会确认（监听listen）
无连接：邮寄与邮箱, 收件人有空去取。
<a href="https://blog.csdn.net/ce123_zhouwei/article/details/8976006" target="_blank" rel="noopener">TCP/UDP</a></li>
</ol>
<p><a href="https://blog.csdn.net/ce123_zhouwei/article/details/8976006" target="_blank" rel="noopener">参考</a>
<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">参考</a>
<a href="https://segmentfault.com/a/1190000020610336" target="_blank" rel="noopener">参考</a></p>
<h2>浏览器对响应的解析</h2>
<p><em>extra:</em>
不同于ISO的七层模型，TCP/IP是四层模型，如图：
<img src="https://imgkr.cn-bj.ufileos.com/f259bd90-7f92-47b3-834f-6bb1980e311b.jpg" alt="pic"></p>
<ul>
<li>应用层：HTTP, SNMP, FTP, TFTP, DNS,</li>
<li>传输层：TCP, UDP</li>
<li>网络层：IP, ICMP, OSPF, IGMP</li>
<li>网络接口层：SLIP, CSLIP, MTU</li>
</ul>
<p>套接字(Socket)
<em>网络层提供的是主机到主机之间的通信</em>
<em>传输层提供的是进程到进程之间的通信</em>
Socket是应用层和传输层之间的一层抽象。如图：
<img src="https://imgkr.cn-bj.ufileos.com/f4279a87-eae4-43ec-83af-c5a78aaebb0a.jpg" alt="pic">
把主机比作一个房子，进程比作方子中的一个个房间，Socket就相当于房间上的门，从房子到房间进出须经过这一道门。
Socket的作用是实现传输层的多路复用和多路分解,在应用层可以同时运行多个进程，每个进程都需要通过传输层来收发分组，而传输层的TCP进程只有一个，当TCP进程收到一个分组后，该怎么确定应该转发给哪个进程呢？答案是通过套接字，这就是多路分解。同样的道理，多路复用就是进程将分组通过各自的套接字转发给传输层。TCP套接字是由一个四元组（源IP地址、源端口号、目的IP地址和目的端口号）来标识的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/45598/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/45598/" class="post-title-link" itemprop="url">HTTP缓存</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-06-28 01:35:12 / 修改时间：13:47:12" itemprop="dateCreated datePublished" datetime="2020-06-28T01:35:12+08:00">2020-06-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>浏览器缓存包括：HTTP缓存，indexDB，cookie，localstorage.现对HTTP缓存稍做分析
&lt;!-- more --&gt;</p>
<p>HTTP缓存分为<strong>强缓存</strong>和<strong>协商缓存</strong>，大致流程是先检查强缓存，可以使用则直接使用缓存，否则发请求检测协商缓存，可以使用则使用缓存，否则从服务器获取资源。
<img src="https://static01.imgkr.com/temp/b95afd6664b84760b061f3ed9b558ece.jpg" alt="pic"></p>
<h1>强缓存</h1>
<h2>Expires</h2>
<p>Expires具体指资源的到期时间，超过这个时间表过期资源。
HTTP1.0标准
缺点是由于使用了具体的日期（年月日时分秒），可能由于时区，当前时间获取错误等原因容易导致错误。</p>
<h2>Cache-Control</h2>
<p>HTTP1.1标准
有以下字段组成：</p>
<ol>
<li><strong>max-age</strong>：指一个时间长度，多长时间之后过期</li>
<li><strong>no-cache</strong>: 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。</li>
<li><strong>no-store</strong>: 禁止缓存。</li>
</ol>
<p>&lt;font color=&quot;red&quot;&gt;Cache-Control优先级高于Expires(使用了时间长度而非具体时间更合理)&lt;/font&gt;</p>
<h1>协商缓存</h1>
<p>强缓存没有命中说明过期了，但是过期不一定就是资源修改不能使用缓存了，这时判断协商缓存</p>
<h2>Last-Motified/If-Modified-Since</h2>
<p>Last-Motified是指服务端最后一次修改资源的时间，响应头部会带上这个标识。浏览器第一次请求之后，会记录这个时间，下次请求时，请求头部的If-Motified-Since即为之前记录的时间。服务端收到If-Motified-Since后会对比，如果修改过就返回最新资源，状态码200，如果没有修改过，返回304.
<img src="https://static01.imgkr.com/temp/b1ace672e50b40d298aa6d42404f66ca.jpg" alt="pic"></p>
<h2>Etag/If-None-Match</h2>
<p>由服务器端上生成的一段 hash 字符串，第一次请求时响应头带上 ETag，之后的浏览器请求会携带上If-None-Match，服务端检查Etag，返回200或304
<img src="https://static01.imgkr.com/temp/091f47e8da8e4945b4b9e2d30cc821ef.jpg" alt="pic"></p>
<p>&lt;font color=&quot;red&quot;&gt;Etag的优先级高于Last-Motified(还是时间的问题，hash值的话不存在这个问题)&lt;/font&gt;</p>
<p><a href="https://zhuanlan.zhihu.com/p/29750583" target="_blank" rel="noopener">参考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/56868/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/56868/" class="post-title-link" itemprop="url">关于跨域</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-27 20:10:35" itemprop="dateCreated datePublished" datetime="2020-06-27T20:10:35+08:00">2020-06-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 13:36:29" itemprop="dateModified" datetime="2020-06-28T13:36:29+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/浏览器/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>hahaha, hello everyone, shit hexo ,this is a seat of seize !_!
&lt;!-- more --&gt;</p>
<h1>同源策略</h1>
<p>同源是指： <strong>协议</strong> <strong>url</strong> <strong>端口</strong> 一致</p>
<p>两个例子理解为什么会出现同源限制：</p>
<ol>
<li>如果百度的后台没有做同源限制，那么别人随便编写一个页面将结果返回给百度后台，再展示响应结果。这样一个搜索引擎似乎就完成了，但是百度后台肯定不会这么干。</li>
<li>购物网站存储了cookie，如果没有同源限制，恶意网站就会获取到cookie以及购物网站的个人信息。</li>
</ol>
<p>同源策略限制以下行为：</p>
<ul>
<li>DOM操作</li>
<li>Ajax</li>
<li>Cookie, LocalStorage, IndexDB</li>
</ul>
<h1>跨域</h1>
<h2>jsonp</h2>
<ol>
<li>申明一个回调函数，函数名当作url参数值，函数的形参为要获取的数据（服务端返回的数据）</li>
<li>创建一个script标签，src为目标地址（参数中传递申明的回调函数）</li>
<li>服务端收到请求之后，将参数中的函数与要返回到数据拼成一个字符串返回</li>
<li>客户端收到响应后，拿到了回调函数的实参，调用回调函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// Client</span><br><span class="line">function jsonp(&#123; url, params, callback &#125;) &#123;</span><br><span class="line">  return new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    let script = document.createElement(&apos;script&apos;)</span><br><span class="line">    window[callback] = function(data) &#123;</span><br><span class="line">      resolve(data)</span><br><span class="line">      document.body.removeChild(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123; ...params, callback &#125; // wd=b&amp;callback=show</span><br><span class="line">    let arrs = []</span><br><span class="line">    for (let key in params) &#123;</span><br><span class="line">      arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = `$&#123;url&#125;?$&#123;arrs.join(&apos;&amp;&apos;)&#125;`</span><br><span class="line">    document.body.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">jsonp(&#123;</span><br><span class="line">  url: &apos;http://localhost:3000/say&apos;,</span><br><span class="line">  params: &#123; wd: &apos;Iloveyou&apos; &#125;,</span><br><span class="line">  callback: &apos;show&apos;</span><br><span class="line">&#125;).then(data =&gt; &#123;</span><br><span class="line">  console.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Server</span><br><span class="line">let express = require(&apos;express&apos;)</span><br><span class="line">let app = express()</span><br><span class="line">app.get(&apos;/say&apos;, function(req, res) &#123;</span><br><span class="line">  let &#123; wd, callback &#125; = req.query</span><br><span class="line">  console.log(wd) // Iloveyou</span><br><span class="line">  console.log(callback) // show</span><br><span class="line">  res.end(`$&#123;callback&#125;(&apos;我不爱你&apos;)`)</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(3000)</span><br></pre></td></tr></table></figure></p>
<p>jsonp方式跨域最大的问题是只支持&lt;font color='red'&gt;GET&lt;/font&gt;方式。</p>
<h2>CORS</h2>
<p>CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
CORS对于前端来说是没有什么特殊的，因为浏览器自动执行，与同源的AJAX通信没有差别，代码完全一样。<strong>浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求。</strong></p>
<h2>简单请求</h2>
<p>满足以下条件就是简单请求：</p>
<ul>
<li>请求方式为HEAD、POST 或者 GET</li>
<li>Content-Type值为text/plain 或 multipart/form-data 或 application/x-www-form-urlencoded</li>
</ul>
<p>对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET /cors HTTP/1.1</span><br><span class="line">Origin: http://api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla/5.0</span><br></pre></td></tr></table></figure></p>
<p>服务器根据<strong>Origin</strong>字段来判断请求来自哪个源，以及是否接受请求。</p>
<ul>
<li>
<p>如果不接受，服务器会返回一个正常的HTTP回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段，就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。</p>
</li>
<li>
<p>如果接受，服务器返回的响应，会多出几个头信息字段：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>Access-Control-Allow-Origin :该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求</p>
</li>
<li>
<p>Access-Control-Allow-Credentials: 该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
</li>
<li>
<p>Access-Control-Expose-Headers:该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。</p>
</li>
</ul>
<p><strong>withCredentials</strong>
CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">xhr.send(&apos;user=admin&apos;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// jquery</span><br><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: true    // 前端设置是否带cookie</span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><em>需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。</em></p>
<h2>非简单请求</h2>
<p>请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。
非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求。&lt;font color='red'&gt;OPTIONS方式&lt;/font&gt;
浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url = &apos;http://api.alice.com/cors&apos;;</span><br><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&apos;PUT&apos;, url, true);</span><br><span class="line">xhr.setRequestHeader(&apos;X-Custom-Header&apos;, &apos;value&apos;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1</span><br><span class="line"> Origin: http://api.bob.com</span><br><span class="line"> Access-Control-Request-Method: PUT</span><br><span class="line"> Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line"> Host: api.alice.com</span><br><span class="line"> Accept-Language: en-US</span><br><span class="line"> Connection: keep-alive</span><br><span class="line"> User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure></p>
<p>除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段。</p>
<ul>
<li>Access-Control-Request-Method：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。</li>
<li>Access-Control-Request-Headers：该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header</li>
</ul>
<p>响应：
服务器收到&quot;预检&quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache/2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http://api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout=2, max=100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text/plain</span><br></pre></td></tr></table></figure></p>
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<p>如果服务器不接受请求，则返回一个正常HTTP响应，里边没有关于CORS的字段，客户端的XMLHttPRequest对象就会捕捉到错误，触发onerror回调
如果接受，回应字段如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure></p>
<p>Access-Control-Allow-Methods：该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次&quot;预检&quot;请求。</p>
<p>注意：一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<h1>node中间代理</h1>
<p>前端代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure></p>
<p>服务端代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/&apos;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &apos;http://www.domain2.com:8080&apos;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line"></span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;);</span><br><span class="line">        res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&apos;Proxy server is listen at port 3000...&apos;);</span><br></pre></td></tr></table></figure></p>
<h1>nginx反向代理</h1>
<p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。
实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<h1>webSocket</h1>
<p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。
原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。
前端代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&apos;http://www.domain2.com:8080&apos;);</span><br><span class="line"></span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&apos;connect&apos;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">        console.log(&apos;data from server: ---&gt; &apos; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&apos;disconnect&apos;, function() &#123; </span><br><span class="line">        console.log(&apos;Server socket has closed.&apos;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>后端代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var socket = require(&apos;socket.io&apos;);</span><br><span class="line"></span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Content-type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br><span class="line"></span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&apos;connection&apos;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">        client.send(&apos;hello：&apos; + msg);</span><br><span class="line">        console.log(&apos;data from client: ---&gt; &apos; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&apos;disconnect&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;Client socket has closed.&apos;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h1>document.domain</h1>
<p>要求主域名相同，结合iframe实现
...</p>
<p><a href="https://www.jianshu.com/p/a0dd1e712c3a" target="_blank" rel="noopener">详细参考</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/42543/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/42543/" class="post-title-link" itemprop="url">async/await及相关思考</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-26 16:55:29" itemprop="dateCreated datePublished" datetime="2020-06-26T16:55:29+08:00">2020-06-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 13:50:17" itemprop="dateModified" datetime="2020-06-28T13:50:17+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/JavaScript/" itemprop="url" rel="index"><span itemprop="name">JavaScript</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>JS关于异步编程的解决方案:
&lt;!-- more --&gt;</p>
<ol>
<li>回调函数
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ajax(url, () =&gt; &#123;</span><br><span class="line">    // 处理逻辑</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p>缺点：容易写出<strong>回调地狱</strong></p>
<ol start="2">
<li>事件监听
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&apos;done&apos;, f2);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>缺点：整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<ol start="3">
<li>发布订阅/观察者模式</li>
<li>promise， generator 与 async/await</li>
</ol>
<h1>Promise</h1>
<p>如上所述，回调函数的缺点是容易写出回调地狱，导致代码难以阅读和维护，以及混乱的错误处理（可能每一次回调都需专门的错误处理，而promise只需要在最后catch就行）。</p>
<h2>构造函数promise</h2>
<p>参数是一个函数，函数的两个参数分别是resolve和reject</p>
<h2>then</h2>
<p>在实例之后.then,参数是两个函数，第一个函数是resolve时执行，第二个函数时reject时执行。*每个函数的参数是之前resolve或reject传过来的。</p>
<h2>catch</h2>
<p>一般在then之后catch。相当于then的第二个参数。这样做的好处是<strong>既可以捕获实例的错误，也可以捕获then的错误</strong></p>
<h2>all</h2>
<p>参数是一个数组，数组的每一项都是promise，如果每一项都resolve，将各项的返回值组成一个数组返回给回调函数，如果有一个reject，将这个reject项的结果返回给回调函数。
<strong>all各项的执行是并发的，可以节约时间</strong></p>
<h2>race</h2>
<p>数组中有一个resolve，将那个项的结果返回给回调函数。<strong>典型应用：规定时间内请求一个接口，超时则返回</strong></p>
<h1>async/await</h1>
<p><strong>async函数中遇到await的地方（是promise）会等待其resolve再执行下面的代码（回调函数）</strong>
但问题在于promise中一大堆then似乎并不优雅，并且有时候不得不在then还得执行then，错误捕获也不完美（匿名函数）,所以async/await出现了。他将异步代码以同步的形式表现出来。</p>
<h2>一个例子</h2>
<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="line"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="line"> */</span><br><span class="line">function takeLongTime(n) &#123;</span><br><span class="line">    return new Promise(resolve =&gt; &#123;</span><br><span class="line">        setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step1(n) &#123;</span><br><span class="line">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step2(n) &#123;</span><br><span class="line">    console.log(`step2 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step3(n) &#123;</span><br><span class="line">    console.log(`step3 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>promise
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(time2 =&gt; step2(time2))</span><br><span class="line">        .then(time3 =&gt; step3(time3))</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">            console.log(`result is $&#123;result&#125;`);</span><br><span class="line">            console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br><span class="line">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="line">// step1 with 300</span><br><span class="line">// step2 with 500</span><br><span class="line">// step3 with 700</span><br><span class="line">// result is 900</span><br><span class="line">// doIt: 1507.251ms</span><br></pre></td></tr></table></figure></p>
<p>async:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    const time2 = await step1(time1);</span><br><span class="line">    const time3 = await step2(time2);</span><br><span class="line">    const result = await step3(time3);</span><br><span class="line">    console.log(`result is $&#123;result&#125;`);</span><br><span class="line">    console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure></p>
<p>现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function step1(n) &#123;</span><br><span class="line">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step2(m, n) &#123;</span><br><span class="line">    console.log(`step2 with $&#123;m&#125; and $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(m + n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function step3(k, m, n) &#123;</span><br><span class="line">    console.log(`step3 with $&#123;k&#125;, $&#123;m&#125; and $&#123;n&#125;`);</span><br><span class="line">    return takeLongTime(k + m + n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>promise:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    step1(time1)</span><br><span class="line">        .then(time2 =&gt; &#123;</span><br><span class="line">            return step2(time1, time2)</span><br><span class="line">                .then(time3 =&gt; [time1, time2, time3]);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(times =&gt; &#123;</span><br><span class="line">            const [time1, time2, time3] = times;</span><br><span class="line">            return step3(time1, time2, time3);</span><br><span class="line">        &#125;)</span><br><span class="line">        .then(result =&gt; &#123;</span><br><span class="line">            console.log(`result is $&#123;result&#125;`);</span><br><span class="line">            console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">        &#125;);</span><br><span class="line">&#125;</span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure></p>
<p>async:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">async function doIt() &#123;</span><br><span class="line">    console.time(&quot;doIt&quot;);</span><br><span class="line">    const time1 = 300;</span><br><span class="line">    const time2 = await step1(time1);</span><br><span class="line">    const time3 = await step2(time1, time2);</span><br><span class="line">    const result = await step3(time1, time2, time3);</span><br><span class="line">    console.log(`result is $&#123;result&#125;`);</span><br><span class="line">    console.timeEnd(&quot;doIt&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doIt();</span><br></pre></td></tr></table></figure></p>
<p><a href="https://segmentfault.com/a/1190000007535316" target="_blank" rel="noopener">参考</a></p>
<h2>原理（自动执行机）</h2>
<p>async实际就是generator函数的语法糖（generator + 自动执行机）
最简单的自动执行机：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function spawn(genF) &#123;</span><br><span class="line">  return new Promise(function(resolve, reject) &#123;</span><br><span class="line">    const gen = genF();</span><br><span class="line">    function step(nextF) &#123;</span><br><span class="line">      let next;</span><br><span class="line">      next = nextF();</span><br><span class="line">      if(next.done) &#123;</span><br><span class="line">        return resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      Promise.resolve(next.value).then(function(v) &#123;</span><br><span class="line">        step(function() &#123; return gen.next(v); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(function() &#123; return gen.next(undefined); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>注意</h2>
<p>当async函数中多个异步操作没有依赖关系时，不适合写成多个await（因为await同步执行，会阻塞）,此时应考虑promise.all()</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/45346/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/45346/" class="post-title-link" itemprop="url">关于http,https与版本</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 23:13:27" itemprop="dateCreated datePublished" datetime="2020-06-22T23:13:27+08:00">2020-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 13:47:19" itemprop="dateModified" datetime="2020-06-28T13:47:19+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/网络/" itemprop="url" rel="index"><span itemprop="name">网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>http,https,对称加密，非对称加密，数字签名，数字证书这些概念除了要知道他们是什么之外，更重要的是知道他们为什么是这样的。从一个故事串联起他们：</p>
<p>&lt;!-- more --&gt;</p>
<h1>一个故事</h1>
<h2>http</h2>
<p>假如有两个人A和B,它们之间通信采用了http协议，简单快捷，但是http是明文传输的，他们传输的信息随时有可能轻易被监听，怎么办？</p>
<h2>对称加密</h2>
<p>他们商量了一下使用加密的方式,也就是他们都有一个<strong>共同</strong>的密钥，在A发送信息之前先将信息通过密钥加密，B收到信息之后用密钥解密就能得到信息了。由于别人没有密钥，只能得到加密过的信息，没有用。但是存在一个问题：如果发送密钥的过程被监听怎么办？</p>
<h2>非对称加密</h2>
<p>A和B又使用了一种新的加密方式：加密和解密的密钥是不同的，加密的密钥称之为公钥，解密的密钥称之为私钥，公钥所有人都知道，私钥只有自己知道。当A想要给B发送信息时，先通过B的公钥加密，B得到后再用私密解密。别人只能拿到B的公钥和公钥加密过的信息，没有私密所以无法解密。
但是由于非对称加密的速度比对称加密慢几十上百倍，所以一般采用两者结合的方式：先使用非对称加密传输一个对称加密的密钥，之后再通过密钥进行对称加密传输。
看似问题解决了，但依然存在一种问题：<em>中间人攻击</em></p>
<h2>中间人攻击</h2>
<p>在非对称加密的过程中，在A得知B的公钥过程中，并不能确定这个公钥真的是B的，比如中间人C把自己的公钥发给A，让A以为这个公钥是B的，A发送的信息实际上是通过C的公钥加密过的，C肯定有自己的私钥，不但能指导A发送到信息，还能用B的公钥发送一些假信息，这样A和B都不知道信息已经被篡改了。</p>
<h2>证书</h2>
<p>将公钥和个人信息发在一起，称之为证书。A得到B的公钥时查看个人信息，似乎就能防止中间人攻击了。但是证书被篡改怎么办？比如C拿到B的证书之后，修改证书中B的公钥替换成C的，个人信息不变，再发送给A，似乎又有问题了。</p>
<h2>消息摘要</h2>
<p>使用一种新算法Hash加密证书，这种算法的特点是加密过的信息只要修改过一点点就截然不同很容易察觉。所以 <code>证书 + 算法 = 消息摘要</code>以后就发送消息摘要。但是问题又来了：如果C将A的消息摘要整个替换怎么办？</p>
<h2>签名 + 证书</h2>
<p>类似于现实世界中的公证处，网络世界也有公证处：CA机构，CA的私钥和公钥大家都认可，公钥很难被替换。
终极大招：B将B的消息摘要通过CA私钥加密后得到数字签名，数字签名和消息摘要（证书 + Hash算法）称为数字证书，将数字证书发送给A,A拿到数字证书后先用CA公钥解密得到消息摘要XX,再用相同的Hash算法解密得到消息摘要YY,对比XX和YY似乎就解决了问题。</p>
<p>总结：
防止公钥与人不对应：个人信息 + 公钥 = 证书 ----&gt; 证书被修改
防止证书被篡改：证书 + Hash算法 = 消息摘要（只要被修改就能查觉） -----&gt;  替换整个消息摘要
防止替换消息摘要：消息摘要 + CA私密加密 = 数字签名， 数字签名 + 消息摘要 = 数字证书
得到数字证书： 用同样的Hash 算法， 再次生成消息摘要，CA的公钥对数字签名解密， 得到CA创建的消息摘要，两者一比。</p>
<h1>RSA加密算法</h1>
<h2>又一个小故事</h2>
<h2>RSA加密过程：</h2>
<ol>
<li>选两个大质数p和q ,N = pq</li>
<li>r = (p-1)(q-1)</li>
<li>小于r的数e,求e关于模r的模反元素d</li>
<li>销毁p,q
(N,e)是公钥，(N,d)是私钥</li>
</ol>
<p>欧拉函数：fn(n) = 小于n的所有n的互质数数目，如fn(8)=4（1,3,5,7）
模反元素：如果两个正整数a和n互质，那么一定可以找到整数b，使得 ab-1 被n整除，或者说ab被n除的余数是1。这时，b就叫做a的“模反元素”。</p>
<h3>加密过程</h3>
<p>原文n:通过
<code>n^e = c(mod N)</code>
得到c,发送c</p>
<h3>解密过程</h3>
<p>将c，通过
<code>c^d = n(mod N)</code>
得到原文n</p>
<h3>原理</h3>
<p><code>c^d ≡ n^(e·d)(mod N)</code>
以及ed ≡ 1 (mod p-1)和ed ≡ 1 (mod q-1)。由费马小定理可证明（因为p和q是质数）
n^(e·d)≡ n(mod p) 和 n^(e·d) ≡ n (mod q)
故：
<code>n(^e·d) ≡ n (mod pq)</code></p>
<h1>HTTP各版本异同</h1>
<h2>HTTP/1.0</h2>
<p>1.0版本的工作方式是每次TCP连接只能发送一个请求，当服务器响应后就会关闭这次连接，下一个请求需要再次建立TCP连接，就是不支持keepalive.
为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。
<code>Connection: keep-alive</code></p>
<h2>HTTP/1.1</h2>
<h3>持久连接</h3>
<p>1.1 版的最大变化，就是引入了<strong>持久连接</strong>,<em>即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive.一个TCP连接可以允许多个HTTP请求</em></p>
<h3>管道机制</h3>
<p>一个TCP连接里，<strong>允许多个请求同时发送</strong>，增加了并发性，进一步改善了HTTP协议的效率。以前是客户端想要请求资源A和B,先发请求A，得到响应再发请求B.现在是同时发送请求A和B.</p>
<h2>HTTP/2.0</h2>
<h3>多工</h3>
<p>在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了&quot;队头堵塞&quot;。</p>
<h3>二进制协议</h3>
<p>1.1中头信息是文本，数据体可以说文本和二进制。2.0中头信息和数据体都是二进制，通常为“帧”</p>
<h1>常用的请求头与响应头字段</h1>
<p>五层模型：
<img src="https://static01.imgkr.com/temp/f2426aa90a0c4aacbfa764b8991c584d.png" alt="pic"></p>
<p>请求实例：
<img src="https://static01.imgkr.com/temp/9398591a7b8e4a81a22592e9a320949a.png" alt="pic"></p>
<p>响应实例：
<img src="https://static01.imgkr.com/temp/4b69e37d98994b22b2c0930d88e9e6c8.png" alt="pic"></p>
<p>请求与响应通用字段：
<img src="https://static01.imgkr.com/temp/69a0d43cb2ce430daaeee69b4c4fe440.png" alt="pic"></p>
<p>常见请求头：
<img src="https://static01.imgkr.com/temp/ed4c743451d84ec9984959c4ce0c5213.png" alt="pic"></p>
<p>常见响应头：
<img src="https://static01.imgkr.com/temp/9c2e49a4b5ad4217a354f8491e5e06cb.png" alt="pic"></p>
<p><a href="https://www.zhihu.com/search?type=content&amp;q=RSA" target="_blank" rel="noopener">RSA知乎</a>
<a href="https://blog.csdn.net/sunmenggmail/article/details/11994013" target="_blank" rel="noopener">RSA</a>
<a href="https://blog.csdn.net/qq_22238021/article/details/81197157" target="_blank" rel="noopener">HTTP</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/30663/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/30663/" class="post-title-link" itemprop="url">分清cookie, session与token</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-22 15:09:05" itemprop="dateCreated datePublished" datetime="2020-06-22T15:09:05+08:00">2020-06-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 13:37:05" itemprop="dateModified" datetime="2020-06-28T13:37:05+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/浏览器/" itemprop="url" rel="index"><span itemprop="name">浏览器</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>这三者分别是什么？有什么用？相互之间有什么关系？让我们一探究竟</p>
<p>&lt;!-- more --&gt;</p>
<h1>cookie</h1>
<p>由于HTTP协议是无状态的，为了实现有状态(<em>比如同样是点赞功能，游客和用户发送的请求需要加以区分</em>),就需要用到Cookie,它其实就是一个个<strong>存储在客户端的键值对</strong>，仅仅是浏览器实现的一种存储数据功能，下次请求会携带上Cookie。
两个特点：</p>
<ol>
<li>存储在客户端</li>
<li>不可跨域</li>
</ol>
<p>Cookie的重要属性：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>name=value</td>
<td>键值对，设置 Cookie 的名称及相对应的值，都必须是字符串类型</td>
</tr>
<tr>
<td>domain</td>
<td>指定 cookie 所属域名，默认是当前域名</td>
</tr>
<tr>
<td>path</td>
<td>指定 cookie 在哪个路径（路由）下生效，默认是 '/'</td>
</tr>
<tr>
<td>maxAge</td>
<td>cookie 失效的时间，单位秒</td>
</tr>
<tr>
<td>expires</td>
<td>过期时间，在设置的某个时间点后该 cookie 就会失效</td>
</tr>
<tr>
<td>httpOnly</td>
<td>无法通过JS脚本读取cookie, 但还是能通过Application手动修改 cookie</td>
</tr>
</tbody>
</table>
<p>缺点：</p>
<ol>
<li>不安全</li>
<li>占服务端空间</li>
<li>存储量小(一个域20条，大小只有4k)</li>
<li>只能村字符串类型</li>
</ol>
<h1>session</h1>
<p>session是另一种实现状态的机制，一般通过cookie实现。
session也可以理解为一种vk形式，v是sessionId,由客户端存储，v为session，服务端存储(一般用到数据库)
过程：
<img src="https://static01.imgkr.com/temp/6a7eec57993147d4ad5e18e604aff0f3.jpg" alt="pic"></p>
<p>缺点：</p>
<ol>
<li>扩展性不好， 比如服务器集群，需要session共享</li>
<li>占据服务端大量资源</li>
</ol>
<p>&lt;font color=&quot;red&quot;&gt;由于存储在服务端，客户端只保存sessionId, 所以解决了cookie的安全问题.且不止能存字符串类型，且可信息量大，cookie可长时间保持，session顾名思义只存在于一次会话&lt;/font&gt;</p>
<h1>token</h1>
<p>（令牌）
token的组成：uid(用户唯一标识符),time(时间戳)，sign(签名)
过程：
<img src="https://static01.imgkr.com/temp/fbf235acb9c44be482d3d14f9621514a.jpg" alt="pic">
由图可见，与session区别在于多了数字签名过程，这相当于用服务端时间换取空间。</p>
<ul>
<li>每一次请求都需要携带 token，需要把 token 放到 HTTP 的 Header 里</li>
<li>基于 token 的用户认证是一种服务端无状态的认证方式，服务端不用存放 token 数据。用解析 token 的计算时间换取 session 的存储空间，从而减轻服务器的压+力，减少频繁的查询数据库</li>
<li>token 完全由应用管理，所以它可以避开同源策略（避免CSRF）</li>
</ul>
<p>用户操作时token过期问题，</p>
<ol>
<li>每次操作推迟过期时间（也是session的方案）</li>
<li>refresh token     服务端生成token的同时生成refresh token，当token过期时客户端发送refresh到服务端验证</li>
</ol>
<p>已注销但Token没过期的问题</p>
<ol>
<li>可以前后端协商，当用户注销前端则同时注销Token，故默认后端收到的Token都是有效的</li>
</ol>
<p>Token 与 Session区别：</p>
<ol>
<li>token安全性好于session</li>
<li>token实现了服务端的无状态化</li>
</ol>
<h1>JWT</h1>
<p>JWT类似于token
JSON Web Token（缩写 JWT）是目前最流行的跨域认证解决方案。
JWT也是将信息存储于客户端</p>
<p>过程：
<img src="https://static01.imgkr.com/temp/ae6b546e80844bb38fbb3ae02d6c495d.jpg" alt="pic"></p>
<p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户，就像下面这样：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;姓名&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;角色&quot;: &quot;管理员&quot;,</span><br><span class="line">  &quot;到期时间&quot;: &quot;2018年7月1日0点0分&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名.
服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>
<p>具体JWT是一个字符串，由两个.隔开分成三部分：</p>
<ol>
<li>Header（头部）</li>
<li>Payload（负载）</li>
<li>Signature（签名）</li>
</ol>
<h2>组成：</h2>
<h3>header</h3>
<p>header描述 JWT 的元数据
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3>payload</h3>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p>
<h3>Signature</h3>
<p>Signature 部分是对前两部分的签名，防止数据篡改。</p>
<h2>使用方式</h2>
<p>客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。
此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息<strong>Authorization</strong>字段里面。
<code>Authorization: Bearer &lt;token&gt;</code>
或者POST数据体里，或者URL中</p>
<h2>缺点</h2>
<p>JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。</p>
<p>Token 和 JWT 的区别
相同：</p>
<ul>
<li>都是访问资源的令牌</li>
<li>都可以记录用户的信息</li>
<li>都是使服务端无状态化</li>
<li>都是只有验证成功后，客户端才能访问服务端上受保护的资源
不同</li>
<li>Token：服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。</li>
<li>JWT： 将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。</li>
</ul>
<p><a href="https://juejin.im/post/5e055d9ef265da33997a42cc#heading-10" target="_blank" rel="noopener">三者详细总结</a>
<a href="https://juejin.im/post/5a6c60166fb9a01caf37a5e5" target="_blank" rel="noopener">Token认证</a>
<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JWT</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/45373/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/45373/" class="post-title-link" itemprop="url">我的排序算法总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-16 21:05:18" itemprop="dateCreated datePublished" datetime="2020-06-16T21:05:18+08:00">2020-06-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 13:47:36" itemprop="dateModified" datetime="2020-06-28T13:47:36+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>现对各排序算法通过Javascript进行总结</p>
<p>&lt;!-- more --&gt;</p>
<p><img src="https://imgkr.cn-bj.ufileos.com/21afe96e-3846-4f2d-b1fc-3cb46b30ac22.jpg" alt="pic"></p>
<p><em>extra</em></p>
<h1>二分查找</h1>
<p>二分查找的条件为有序，数组。基本思想为先与数组中间元素比较，通过结果选择左半边或右半边进行递归。终止条件就是数组长度只有一项时，查找到或者没找到。
代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function binarySearch(arr, start ,end, target)&#123;</span><br><span class="line">    if(end - start &lt;= 0)&#123;</span><br><span class="line">        if(target === arr[start])&#123;</span><br><span class="line">            return start</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">             return &quot;not find&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let mid = (start + end) &gt;&gt; 1</span><br><span class="line">    if(arr[mid] &gt; target)&#123;</span><br><span class="line">        return binarySearch(arr, 0, mid - 1, target)</span><br><span class="line">    &#125;else if(arr[mid] &lt; target)&#123;</span><br><span class="line">        return binarySearch(arr,mid + 1 , end, target)</span><br><span class="line">    &#125;else &#123;</span><br><span class="line">        return mid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(log2N)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h1>快速排序</h1>
<p>快排思想：</p>
<ol>
<li>随便选择一个哨兵（第一个元素）,使得比哨兵小的元素都在其左边，比哨兵大的元素都在右边，再分别对左右子数组进行上述操作，直到数组长度为一。</li>
</ol>
<h2>递归法</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function quickSort(arr, left, right)&#123;</span><br><span class="line">    if(left &gt;= right)&#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    let i = left, j = right, flag = left</span><br><span class="line">    let temp</span><br><span class="line">    while(i &lt; j)&#123;</span><br><span class="line">        while(arr[j] &gt;= arr[flag] &amp;&amp; j &gt; flag)&#123;</span><br><span class="line">            j--</span><br><span class="line">        &#125;</span><br><span class="line">        if(i &gt;= j)&#123;</span><br><span class="line">            break</span><br><span class="line">        &#125;</span><br><span class="line">        while(arr[i] &lt;= arr[flag] &amp;&amp; i &lt; j)&#123;</span><br><span class="line">            i++</span><br><span class="line">        &#125;</span><br><span class="line">        temp = arr[flag]</span><br><span class="line">        arr[flag] = arr[j]</span><br><span class="line">        arr[j] = arr[i]</span><br><span class="line">        arr[i] = temp</span><br><span class="line">        flag = i</span><br><span class="line">    &#125;</span><br><span class="line">    quickSort(arr, left, flag - 1)</span><br><span class="line">    quickSort(arr, flag + 1, right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当数据量过大递归次数过多，会出现栈溢出，考虑数组模拟栈：</p>
<h2>非递归法</h2>
<p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function _quickSort(num, left, right) &#123;</span><br><span class="line">    var list = [[left, right]]; // 将[left,right]存入数组中，类似于递归入栈</span><br><span class="line">    while (list.length &gt; 0) &#123; // 若list不为空，循环弹出list最后一个数组进行快排</span><br><span class="line">        var now = list.pop(); // 弹出list末尾。(也可用list.shift()取出list第一个数组，但在数据量较大时，这种方式效率较低)</span><br><span class="line">        if (now[0] &gt;= now[1]) &#123; // 若左右指针相遇，待排序数组长度小宇1，则无需进行快排(注意不能写成now[0]==now[1]，这里now[0]是有可能大于now[1]的</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        var i = now[0], j = now[1], flag = now[0]; // 以下与递归方法相同，请参考上面的递归详解</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            while (num[j] &gt;= num[flag] &amp;&amp; j &gt; flag) j--;</span><br><span class="line">            if (i &gt;= j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            while (num[i] &lt;= num[flag] &amp;&amp; i &lt; j) i++;</span><br><span class="line">            let temp = num[flag];</span><br><span class="line">            num[flag] = num[j];</span><br><span class="line">            num[j] = num[i];</span><br><span class="line">            num[i] = temp;</span><br><span class="line">            flag = i;</span><br><span class="line">        &#125;</span><br><span class="line">        list.push([now[0], flag - 1]); // 将flag左边数组作为待排序数组，只需将左右指针放入list即可。</span><br><span class="line">        list.push([flag + 1, now[1]]); // 将flag右边数组作为待排序数组，只需将左右指针放入list即可。</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最好</td>
<td>最坏</td>
</tr>
<tr>
<td>O(nlogn)</td>
<td>O(n^2)</td>
</tr>
</tbody>
</table>
<p>&lt;font color=&quot;red&quot;&gt;稳定性：不稳定&lt;/font&gt;</p>
<p><a href="https://blog.csdn.net/xuyangxinlei/article/details/81062015" target="_blank" rel="noopener">参考</a></p>
<h1>冒泡排序</h1>
<p>在每一轮的排序中，对待排序子数组中的相邻元素进行比较，如果逆序，则交换位置。当一轮结束后，待排序子数组中最大的元素便出现了子数组最后一个位置。
代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function bubbleSort(nums)&#123;</span><br><span class="line">    let temp</span><br><span class="line">    for(let i = 0 ; i &lt; nums.length - 1; i++)&#123;</span><br><span class="line">        for(let j = 0 ; j &lt; nums.length - i - 1 ; j++)&#123;</span><br><span class="line">            if(nums[j + 1] &lt; nums[j])&#123;</span><br><span class="line">                temp = nums[j + 1]</span><br><span class="line">                nums[j + 1] = nums[j]</span><br><span class="line">                nums[j] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1>选择排序</h1>
<p>大致思想是找到待排序数组的最小元素与[0]位置的项交换值，再在剩下位置中找到最小元素与[1]位置项交换值，一次类推
代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function selectSort(arr)&#123;</span><br><span class="line">    let temp</span><br><span class="line">    for(let i = 0 ; i &lt; arr.length - 1 ; i++)&#123;</span><br><span class="line">        for(let j = i + 1 ; j &lt; arr.length ; j++)&#123;</span><br><span class="line">            if(arr[j] &lt; arr[i])&#123;</span><br><span class="line">                temp = arr[j]</span><br><span class="line">                arr[j] = arr[i]</span><br><span class="line">                arr[i] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
</tbody>
</table>
<h1>插入排序</h1>
<p>将待排序元素插入到已经有序的序列。
代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function insertSort(arr)&#123;</span><br><span class="line">    let temp</span><br><span class="line">    for(let i = 1 ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">        for(let j = i ; j &gt; 0 ; j--)&#123;</span><br><span class="line">            if(arr[j] &lt; arr[j - 1])&#123;</span><br><span class="line">                temp = arr[j]</span><br><span class="line">                arr[j] = arr[j - 1]</span><br><span class="line">                arr[j - 1] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody>
</table>
<h1>希尔排序</h1>
<p>对于插入排序来说，它只会交换相邻的元素，因此它只能一点一点地从数组地一端移动到另一端，如果最小元素在最右边，需要n-1次交换才能移动最左端。
希尔排序算法思想:使数组中任意间隔为h的元素都是有序地，这样的数组称为h有序数组。然后不断缩小h的值，直到h为1，此时可看作是插入排序。相比于插入排序，这样可以上述的极端情况下，更快的将元素交换到它的正确位置。
代码:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function shellSort(arr)&#123;</span><br><span class="line">    let temp</span><br><span class="line">    let fra = Math.floor(arr.length/2)</span><br><span class="line">    while(fra &gt; 0)&#123;</span><br><span class="line">        for(let i = fra ; i &lt; arr.length ; i++)&#123;</span><br><span class="line">            for(let j = i - fra ; j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j + fra] ; j -= fra)&#123;</span><br><span class="line">                temp = arr[j]</span><br><span class="line">                arr[j] = arr[j + fra]</span><br><span class="line">                arr[j + fra] = temp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fra = Math.floor(fra/2)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>时间复杂度</th>
<th>空间复杂度</th>
<th>稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(n^1.3~2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
</tbody>
</table>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope="" itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/posts/4442/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/ava.png">
      <meta itemprop="name" content="dangsenlin">
      <meta itemprop="description" content="never giveup stronger survival">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dang's technology blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/posts/4442/" class="post-title-link" itemprop="url">webpack热更新原理</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-06-15 20:40:30" itemprop="dateCreated datePublished" datetime="2020-06-15T20:40:30+08:00">2020-06-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-28 13:39:02" itemprop="dateModified" datetime="2020-06-28T13:39:02+08:00">2020-06-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/source/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>现就webpack热更新进行研究</p>
<p>&lt;!-- more --&gt;</p>
<p>源于一道面试题：
<img src="https://imgkr.cn-bj.ufileos.com/95bc5bc2-3d9d-4bf5-8781-9f8beef8d976.jpg" alt="pic">
<a href="https://juejin.im/post/5e6f4b4e6fb9a07cd443d4a5#heading-8" target="_blank" rel="noopener">详细参考</a></p>
<h1>为什么要用HMR?</h1>
<p>比如一个页面有<em>账号</em>，<em>密码</em>，<em>邮箱</em>三个必选框，当我们填写好了账号和密码，在填写邮箱时需要刷新，如果是常规刷新，则会刷新整个页面，则需重新填写账号密码，如果使用了HMR,则账号密码会保留状态，只需关注<em>邮箱</em>即可。</p>
<p>带着以下问题进行探索会更有收获：</p>
<ol>
<li>webpack 可以将不同的模块打包成 bundle 文件或者几个 chunk 文件，但是当我通过 webpack HMR 进行开发的过程中，我并没有在我的 dist 目录中找到 webpack 打包好的文件，它们去哪呢？</li>
<li>通过查看 webpack-dev-server 的 package.json 文件，我们知道其依赖于 webpack-dev-middleware 库，那么 webpack-dev-middleware 在 HMR 过程中扮演什么角色？</li>
<li>使用 HMR 的过程中，通过 Chrome 开发者工具我知道浏览器是通过 websocket 和 webpack-dev-server 进行通信的，但是 websocket 的 message 中并没有发现新模块代码。打包后的新模块又是通过什么方式发送到浏览器端的呢？为什么新的模块不通过 websocket 随消息一起发送到浏览器端呢？</li>
<li>浏览器拿到最新的模块代码，HMR 又是怎么将老的模块替换成新的模块，在替换的过程中怎样处理模块之间的依赖关系？</li>
<li>当模块的热替换过程中，如果替换模块失败，有什么回退机制吗？</li>
</ol>
<h1>流程解析</h1>
<p>先看一张图：
<a href="https://imgkr.cn-bj.ufileos.com/6d0f4fcb-6f84-4387-a8ea-0d4978e734d7.jpg" target="_blank" rel="noopener">pic</a></p>
<ol>
<li>webpack的watch模式下，对文件进行监听。</li>
<li>webpack-dev-server引用的中间件webpack-dev-middleware与webpack进行交互，前者调用后者暴露的API进行监控。</li>
<li>webpack-dev-server也对文件进行了监控，如果有相应配置则在文件变化后会进行live reload。</li>
<li>webpack-dev-server客户端（浏览器）与服务端建立了webSocket长连接。传递的信息主要包括新模块的hash值。</li>
<li>webpack-dev-server并不能请求到更新的模块，也不能进行更新操作，而又把这些工作又交回webpack.</li>
<li>（7, 8, 9）HotModuleReplacement.runtime接受到上一步的hash值，通过JsonpMainTemplate.runtime向server发送Ajax请求，得到一个包含新模块hash的json文件，继续通过jsonp新模块的代码。</li>
<li>HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li>
<li>上个步骤失败则进行live reload操作。</li>
</ol>
<h1>实例分析</h1>
<p>文件结构：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--hello.js</span><br><span class="line">--index.js</span><br><span class="line">--index.html</span><br><span class="line">--package.json</span><br><span class="line">--webpack.config.js</span><br></pre></td></tr></table></figure></p>
<p>项目入口文件是index.js文件，hello.js是入口文件的依赖，webpack.config.js如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&apos;path&apos;)</span><br><span class="line">const webpack = require(&apos;webpack&apos;)</span><br><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &apos;./index.js&apos;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: &apos;bundle.js&apos;,</span><br><span class="line">        path: path.join(__dirname, &apos;/&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        hot: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>webpack对文件进行watch并打包到内存中</h2>
<p>webpack-dev-middleware 调用 webpack 的 api 对文件系统 watch，当 hello.js 文件发生改变后，webpack 重新对文件进行编译打包，然后保存到内存中。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// webpack-dev-middleware/lib/Shared.js</span><br><span class="line">if(!options.lazy) &#123;</span><br><span class="line">    var watching = compiler.watch(options.watchOptions, share.handleCompilerCallback);</span><br><span class="line">    context.watching = watching;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>&lt;font color=&quot;red&quot;&gt;webpack之所以将文件打包到内存中而不是dist目录中，是因为访问内存速度更快，这一切归功于memory-fs,其是webpack-dev-middleware的一个依赖库&lt;/font&gt;
webpack中该部分源码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// webpack-dev-middleware/lib/Shared.js</span><br><span class="line">var isMemoryFs = !compiler.compilers &amp;&amp; compiler.outputFileSystem instanceof MemoryFileSystem;</span><br><span class="line">if(isMemoryFs) &#123;</span><br><span class="line">    fs = compiler.outputFileSystem;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    fs = compiler.outputFileSystem = new MemoryFileSystem();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2>devServer通知浏览器文件发生改变</h2>
<p>服务端和浏览器端通过webSocket长连接，并且webpack-dev-server 调用 webpack api 监听 compile的 done 事件，当compile 完成后，webpack-dev-server通过 _sendStatus 方法将编译打包后的新模块 hash 值发送到浏览器端。
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// webpack-dev-server/lib/Server.js</span><br><span class="line">compiler.plugin(&apos;done&apos;, (stats) =&gt; &#123;</span><br><span class="line">  // stats.hash 是最新打包文件的 hash 值</span><br><span class="line">  this._sendStats(this.sockets, stats.toJson(clientStats));</span><br><span class="line">  this._stats = stats;</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line">Server.prototype._sendStats = function (sockets, stats, force) &#123;</span><br><span class="line">  if (!force &amp;&amp; stats &amp;&amp;</span><br><span class="line">  (!stats.errors || stats.errors.length === 0) &amp;&amp; stats.assets &amp;&amp;</span><br><span class="line">  stats.assets.every(asset =&gt; !asset.emitted)</span><br><span class="line">  ) &#123; return this.sockWrite(sockets, &apos;still-ok&apos;); &#125;</span><br><span class="line">  // 调用 sockWrite 方法将 hash 值通过 websocket 发送到浏览器端</span><br><span class="line">  this.sockWrite(sockets, &apos;hash&apos;, stats.hash);</span><br><span class="line">  if (stats.errors.length &gt; 0) &#123; this.sockWrite(sockets, &apos;errors&apos;, stats.errors); &#125; </span><br><span class="line">  else if (stats.warnings.length &gt; 0) &#123; this.sockWrite(sockets, &apos;warnings&apos;, stats.warnings); &#125;      else &#123; this.sockWrite(sockets, &apos;ok&apos;); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2>webpack-dev-server/client 接收到服务端消息做出响应</h2>
<p>&lt;font color='red'&gt;之所以此时的浏览器可以作为客户端是因为webpack-dev-server改写的配置文件的entry属性，在其中添加了作为客户端的代码，并运行在浏览器端&lt;/font&gt;
webpack-dev-server/client 当接收到 type 为 hash 消息后会将 hash 值暂存起来，当接收到 type 为 ok 的消息后对应用执行 reload 操作，如下图所示，hash 消息是在 ok 消息之前。
<img src="https://imgkr.cn-bj.ufileos.com/a3b04545-156b-4dfd-92e4-84c57e63bccf.jpg" alt="pic">
在 reload 操作中，webpack-dev-server/client 会根据 hot 配置决定是刷新浏览器还是对代码进行热更新（HMR）。代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// webpack-dev-server/client/index.js</span><br><span class="line">hash: function msgHash(hash) &#123;</span><br><span class="line">    currentHash = hash;</span><br><span class="line">&#125;,</span><br><span class="line">ok: function msgOk() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    reloadApp();</span><br><span class="line">&#125;,</span><br><span class="line">// ...</span><br><span class="line">function reloadApp() &#123;</span><br><span class="line">  // ...</span><br><span class="line">  if (hot) &#123;</span><br><span class="line">    log.info(&apos;[WDS] App hot update...&apos;);</span><br><span class="line">    const hotEmitter = require(&apos;webpack/hot/emitter&apos;);</span><br><span class="line">    hotEmitter.emit(&apos;webpackHotUpdate&apos;, currentHash);</span><br><span class="line">    // ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    log.info(&apos;[WDS] App updated. Reloading...&apos;);</span><br><span class="line">    self.location.reload();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果配置了模块热更新，就调用 webpack/hot/emitter 触发了webpackHotUpdate，将最新 hash 值发送给 webpack，然后将控制权交给 webpack 客户端代码.</p>
<h2>webpack 接收到最新 hash 值验证并请求模块代码</h2>
<p>webpack/hot/dev-server（以下简称 dev-server） 监听第三步 webpack-dev-server/client 发送的 <code>webpackHotUpdate</code> 消息,调用 webpack/lib/HotModuleReplacement.runtime（简称 HMR runtime）中的 check 方法,检测是否有新的更新，在 check 过程中会利用 webpack/lib/JsonpMainTemplate.runtime（简称 jsonp runtime）中的两个方法 hotDownloadUpdateChunk 和 hotDownloadManifest ， 第二个方法是调用 AJAX 向服务端请求是否有更新的文件，如果有将发更新的文件列表返回浏览器端，而第一个方法是通过 jsonp 请求最新的模块代码，然后将代码返回给 HMR runtime，HMR runtime 会根据返回的新模块代码做进一步处理，可能是刷新页面，也可能是对模块进行热更新。
hotDownloadManifest方法获取更新文件列表：
<img src="https://imgkr.cn-bj.ufileos.com/12e720e6-b313-47c6-99b4-47f6865f362f.jpg" alt="pic"></p>
<p>hotDownloadUpdateChunk获取到更新的新模块代码：
<img src="https://imgkr.cn-bj.ufileos.com/8e590f88-27bd-4271-998f-024bfb96f9f9.jpg" alt="pic"></p>
<p>还记得 HMR 的工作原理图解 中的问题 3 吗？为什么更新模块的代码不直接在第三步通过 websocket 发送到浏览器端，而是通过 jsonp 来获取呢？我的理解是，功能块的解耦，各个模块各司其职，dev-server/client 只负责消息的传递而不负责新模块的获取，而这些工作应该有 HMR runtime 来完成，HMR runtime 才应该是获取新代码的地方。再就是因为不使用 webpack-dev-server 的前提，使用 webpack-hot-middleware 和 webpack 配合也可以完成模块热更新流程，在使用 webpack-hot-middleware 中有件有意思的事，它没有使用 websocket，而是使用的 EventSource。综上所述，HMR 的工作流中，不应该把新模块代码放在 websocket 消息中。</p>
<h2>HotModuleReplacement.runtime 对模块进行热更新</h2>
<p>这一步是整个模块热更新（HMR）的关键步骤，而且模块热更新都是发生在HMR runtime 中的 hotApply 方法中,
关键代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// webpack/lib/HotModuleReplacement.runtime</span><br><span class="line">function hotApply() &#123;</span><br><span class="line">    // ...</span><br><span class="line">    var idx;</span><br><span class="line">    var queue = outdatedModules.slice();</span><br><span class="line">    while(queue.length &gt; 0) &#123;</span><br><span class="line">        moduleId = queue.pop();</span><br><span class="line">        module = installedModules[moduleId];</span><br><span class="line">        // ...</span><br><span class="line">        // remove module from cache</span><br><span class="line">        delete installedModules[moduleId];</span><br><span class="line">        // when disposing there is no need to call dispose handler</span><br><span class="line">        delete outdatedDependencies[moduleId];</span><br><span class="line">        // remove &quot;parents&quot; references from all children</span><br><span class="line">        for(j = 0; j &lt; module.children.length; j++) &#123;</span><br><span class="line">            var child = installedModules[module.children[j]];</span><br><span class="line">            if(!child) continue;</span><br><span class="line">            idx = child.parents.indexOf(moduleId);</span><br><span class="line">            if(idx &gt;= 0) &#123;</span><br><span class="line">                child.parents.splice(idx, 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">    // insert new code</span><br><span class="line">    for(moduleId in appliedUpdate) &#123;</span><br><span class="line">        if(Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) &#123;</span><br><span class="line">            modules[moduleId] = appliedUpdate[moduleId];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面 hotApply 方法可以看出，模块热替换主要分三个阶段，
第一个阶段是找出 outdatedModules 和 outdatedDependencies(没有贴出)，
第二个阶段从缓存中删除过期的模块和依赖，
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete installedModules[moduleId];</span><br><span class="line">delete outdatedDependencies[moduleId];</span><br></pre></td></tr></table></figure></p>
<p>三个阶段是将新的模块添加到 modules 中，当下次调用 <strong>webpack_require</strong> (webpack 重写的 require 方法)方法的时候，就是获取到了新的模块代码了。</p>
<p>模块热更新的错误处理，如果在热更新过程中出现错误，热更新将回退到刷新浏览器，这部分代码在 dev-server 代码中，简要代码如下：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">module.hot.check(true).then(function(updatedModules) &#123;</span><br><span class="line">    if(!updatedModules) &#123;</span><br><span class="line">        return window.location.reload();</span><br><span class="line">    &#125;</span><br><span class="line">    // ...</span><br><span class="line">&#125;).catch(function(err) &#123;</span><br><span class="line">    var status = module.hot.status();</span><br><span class="line">    if([&quot;abort&quot;, &quot;fail&quot;].indexOf(status) &gt;= 0) &#123;</span><br><span class="line">        window.location.reload();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>dev-server 先验证是否有更新，没有代码更新的话，重载浏览器。如果在 hotApply 的过程中出现 abort 或者 fail 错误，也进行重载浏览器。</p>
<p><a href="https://zhuanlan.zhihu.com/p/30669007" target="_blank" rel="noopener">参考1</a>
<a href="https://juejin.im/post/5de0cfe46fb9a071665d3df0#heading-2" target="_blank" rel="noopener">参考2</a>
<a href="https://juejin.im/post/5d6d0ee5f265da03f66ddba9" target="_blank" rel="noopener">参考3</a>
<a href="https://juejin.im/post/5e6f4b4e6fb9a07cd443d4a5#heading-8" target="_blank" rel="noopener">参考4</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dangsenlin" src="/images/ava.png">
  <p class="site-author-name" itemprop="name">dangsenlin</p>
  <div class="site-description" itemprop="description">never giveup stronger survival</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dangsenlin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  















  

  

</body>
</html>
